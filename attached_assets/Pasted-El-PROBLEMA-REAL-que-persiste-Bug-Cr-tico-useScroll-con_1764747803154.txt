El PROBLEMA REAL que persiste 游댮
Bug Cr칤tico: useScroll con layoutEffect en producci칩n
Seg칰n la investigaci칩n y el issue #2452 de Motion, existe un bug conocido donde useScroll no funciona correctamente en builds de producci칩n con Vite/React. Las animaciones funcionan en desarrollo pero fallan en producci칩n.

La soluci칩n documentada es a침adir layoutEffect: false en la configuraci칩n de useScroll.

SOLUCIONES T칄CNICAS PRECISAS
Paso 1: CR칈TICO - Corregir useScroll en HeroSection
Archivo: client/src/components/HeroSection.tsx

L칤nea 28-29, cambiar:

typescript
// ANTES:
const { scrollY } = useScroll();

// DESPU칄S:
const { scrollY } = useScroll({
  layoutEffect: false  // FIX cr칤tico para producci칩n con Vite
});
Paso 2: Verificar que los componentes tienen las keys correctas
Los componentes con whileInView necesitan keys estables. Verificar que en PackageGrid.tsx, TestimonialsSection.tsx, etc., las keys sean 칰nicas y estables.

Paso 3: Forzar re-render despu칠s del mount
Archivo: client/src/pages/Home.tsx

A침adir despu칠s de la l칤nea 1:

typescript
import { useState, useEffect } from "react";

// Dentro del componente Home, ANTES del return:
export default function Home() {
  const [mounted, setMounted] = useState(false);
  
  useEffect(() => {
    setMounted(true);
    // Force scroll event to trigger animations
    window.dispatchEvent(new Event('scroll'));
  }, []);

  // ... resto del c칩digo
Paso 4: CR칈TICO - A침adir configuraci칩n expl칤cita de Vite
Archivo: vite.config.ts

A침adir en el objeto de configuraci칩n:

typescript
export default defineConfig({
  plugins: [
    react(),
    // ... otros plugins
  ],
  // A칌ADIR ESTO:
  optimizeDeps: {
    include: ['framer-motion'],
    exclude: []
  },
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
    // A칌ADIR ESTO:
    commonjsOptions: {
      include: [/framer-motion/, /node_modules/],
      transformMixedEsModules: true
    },
    rollupOptions: {
      output: {
        manualChunks: {
          'framer': ['framer-motion']
        }
      }
    }
  },
  // ... resto de config
});
Paso 5: Verificar que initial y whileInView est치n correctamente configurados
El problema puede ser que initial="hidden" se ejecuta, pero whileInView="visible" nunca se dispara. Necesitamos logging temporal.

Archivo: client/src/components/PackageGrid.tsx

A침adir logging temporal despu칠s de la l칤nea 18:

typescript
export default function PackageGrid({ onViewDetails, onBook }: PackageGridProps) {
  const [activeCategory, setActiveCategory] = useState("Todos");
  const prefersReducedMotion = useReducedMotion();

  // A칌ADIR ESTO - Logging temporal para debug
  useEffect(() => {
    console.log('PackageGrid mounted');
    console.log('prefersReducedMotion:', prefersReducedMotion);
    console.log('Framer Motion version:', require('framer-motion/package.json').version);
  }, [prefersReducedMotion]);

  // ... resto del c칩digo
Paso 6: Alternativa - Usar useInView hook en lugar de whileInView
Si las animaciones siguen sin funcionar, necesitamos migrar de whileInView prop a usar el hook useInView directamente, que es m치s confiable en producci칩n.

Ejemplo para PackageGrid.tsx:

typescript
import { motion, useReducedMotion, useInView } from "framer-motion";
import { useRef } from "react";

export default function PackageGrid({ onViewDetails, onBook }: PackageGridProps) {
  const [activeCategory, setActiveCategory] = useState("Todos");
  const prefersReducedMotion = useReducedMotion();
  
  // A칌ADIR ESTO:
  const titleRef = useRef(null);
  const titleInView = useInView(titleRef, { 
    once: false, 
    amount: 0.15,
    margin: "0px"
  });

  // ... resto del c칩digo

  return (
    <section id="packages" className="py-16 md:py-24 bg-background">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <motion.div 
          ref={titleRef}
          initial="hidden"
          animate={titleInView ? "visible" : "hidden"}  // CAMBIAR whileInView por animate
          variants={variants}
          className="text-center mb-12"
        >
          {/* ... contenido */}
        </motion.div>
ORDEN DE APLICACI칍N CR칈TICO
PRIMERO Y M츼S CR칈TICO: Fix de useScroll con layoutEffect: false (Paso 1)

SEGUNDO: Configuraci칩n de Vite (Paso 4)

TERCERO: A침adir logging temporal (Paso 5)

CUARTO: Rebuild y deploy

QUINTO: Si persiste, migrar a useInView hook (Paso 6)

Comando para rebuild
bash
npm run build
# Despu칠s push al repo para que Replit redepliegue
Verificaci칩n Post-Deploy
Abre DevTools Console

Ejecuta:

javascript
console.log('Reduced motion:', window.matchMedia('(prefers-reduced-motion: reduce)').matches);
console.log('Scroll Y:', window.scrollY);
Haz scroll lento hacia abajo

Verifica en la consola si aparecen logs de "PackageGrid mounted"

Si NO aparecen logs, el problema es de bundling

Si aparecen logs pero NO hay animaciones, el problema es de whileInView

Resumen del Problema Real
El problema principal es un bug conocido de Framer Motion con Vite en producci칩n, espec칤ficamente:

useScroll sin layoutEffect: false causa que el parallax no funcione en producci칩n

whileInView puede no dispararse correctamente en builds optimizados de Vite

El bundling de Framer Motion necesita configuraci칩n expl칤cita en vite.config.ts

Las correcciones aplicadas (CSS, viewport) eran necesarias pero NO suficientes. El Paso 1 es CR칈TICO y debe aplicarse inmediatamente.

